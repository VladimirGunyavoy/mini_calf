# Лог принятых решений - Stage 3

**Формат записи**:
```
## Decision N: [Дата YYYY-MM-DD] Краткое название

**Контекст**: Почему нужно было принимать решение
**Варианты**: Какие варианты рассматривались
**Выбор**: Что выбрали
**Обоснование**: Почему выбрали этот вариант
**Последствия**: Что это меняет в проекте
```

---

# Ранее принятые решения (до начала работы)

Эти решения были приняты при планировании Stage 3.

---

## Decision 1: [2026-01-22] Выбор модели Differential Drive

**Контекст**: Нужно выбрать математическую модель для дифференциального привода.

**Варианты**:
- A: Кинематическая (1-го порядка): state=[x,y,θ], action=[v,ω]
- B: Динамическая (2-го порядка): state=[x,y,θ,v,ω], action=[a_v,a_ω]
- C: Гибрид с инерцией: state=[x,y,θ,v,ω], action=[v_cmd,ω_cmd]

**Выбор**: Вариант A (кинематическая модель)

**Обоснование**:
- Самая простая для начала
- Управление интуитивное (v, ω напрямую)
- Достаточно для демонстрации CALF
- Легко расширить до вариантов B/C позже

**Последствия**:
- state_dim = 3, action_dim = 2
- Нет инерции в модели
- Мгновенная реакция на управление

---

## Decision 2: [2026-01-22] Визуализация агента

**Контекст**: Нужно визуально показать ориентацию θ агента.

**Варианты**:
- A: Сфера (как Point Mass) - без ориентации
- B: Cone (конус) - встроенный в Ursina
- C: Triangle mesh (кастомный треугольник)
- D: Arrow (стрелка из линий)

**Выбор**: Вариант B (Cone)

**Обоснование**:
- Встроенная модель в Ursina, не нужен кастомный mesh
- Визуально понятно направление (острый конец = перёд)
- Простая реализация

**Последствия**:
- Нужен rotation_x = 90 чтобы cone смотрел вдоль Z вместо Y
- rotation_y = -θ_deg для ориентации

---

## Decision 3: [2026-01-22] Heatmap для 3D состояния

**Контекст**: CriticHeatmap отображает 2D срез Q-функции. Как отображать для state=[x,y,θ]?

**Варианты**:
- A: Убрать heatmap для Differential Drive
- B: Срез при θ=0 (показываем Q(x, y, θ=0, action=0))
- C: 3D визуализация (сложно)
- D: Несколько срезов для разных θ

**Выбор**: Вариант B (срез при θ=0)

**Обоснование**:
- Простая реализация
- Даёт представление о Q-функции
- θ=0 - это цель, логичный выбор

**Последствия**:
- Добавить параметры state_dim, fixed_theta в CriticHeatmap
- Heatmap показывает только часть Q-функции

---

## Decision 4: [2026-01-22] Архитектура расширяемости

**Контекст**: Как организовать код чтобы легко добавлять новые системы?

**Варианты**:
- A: Отдельные файлы без общего интерфейса
- B: Базовые классы (BaseEnv, BaseDynamicalSystem)
- C: Фабрики + реестр систем
- D: Plugin система

**Выбор**: Вариант B (базовые классы)

**Обоснование**:
- Достаточно для 2-3 систем
- Чистый Python, без лишних абстракций
- Легко понять и поддерживать
- Варианты C/D - overkill для текущего масштаба

**Последствия**:
- Создать BaseEnv и BaseDynamicalSystem
- Рефакторинг PointMassEnv и PointSystem
- Все новые системы наследуются от базовых классов

---

# Новые решения

Записывай новые решения ниже в том же формате.

---

## Decision 5: [YYYY-MM-DD] Название

**Контекст**: 

**Варианты**: 

**Выбор**: 

**Обоснование**: 

**Последствия**: 

---

