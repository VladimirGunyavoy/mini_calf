# Лог принятых решений - Stage 2

**Формат записи**:
```
## Decision N: [Дата YYYY-MM-DD] Краткое название

**Контекст**: Почему нужно было принимать решение
**Варианты**: Какие варианты рассматривались
**Выбор**: Что выбрали
**Обоснование**: Почему выбрали этот вариант
**Последствия**: Что это меняет в проекте
```

---

## Decision 1: [2026-01-21] Вариант плана оптимизации

**Контекст**: Нужно выбрать стратегию оптимизации - фокус на производительность, архитектуру или смешанный подход.

**Варианты**:
- A: Только производительность (batch operations → trails → heatmap → profiling)
- B: Только архитектура (batch ops → config → refactor → builder → profiling)
- C: Смешанный (batch ops + config → refactor → profiling → визуализация)

**Выбор**: Вариант C (смешанный)

**Обоснование**:
- Batch operations (STAGE 1) - критический фикс, без него ничего не работает
- Config (STAGE 2) - быстрый win для удобства экспериментов
- Refactor (STAGE 3) - улучшает читаемость и расширяемость
- Profiling (STAGE 4) - позволяет найти следующие bottleneck
- Visualization (STAGE 5) - оптимизация на основе данных профилирования

**Последствия**:
- 6 стадий вместо 4-5
- Более длительное выполнение Stage 2 (~12-15 часов работы)
- Баланс между quick wins и долгосрочными улучшениями

---

## Decision 2: [2026-01-21] train_calf_visual.py остаётся как источник кода

**Контекст**: train_calf_visual.py изначально был тестом, но стал основным файлом. Нужно решить что с ним делать.

**Варианты**:
- A: Переименовать train_calf_visual.py → main.py (и старый main.py → old_main.py)
- B: Оставить train_calf_visual.py как есть, создать новый main.py с нуля
- C: Удалить train_calf_visual.py после переноса кода

**Выбор**: Вариант B (оставить как источник, создать новый main.py)

**Обоснование**:
- train_calf_visual.py содержит весь функционал (974 строки)
- Лучше сохранить working code для reference
- Новый main.py будет чистым (100-150 строк) с использованием компонентов
- Старый main.py → old_main.py для архива

**Последствия**:
- 3 файла: old_main.py (архив), train_calf_visual.py (reference), main.py (новый)
- Можно сравнивать реализации
- Риск рассинхронизации между файлами

---

## Decision 3: [2026-01-21] Централизованная config через dataclasses

**Контекст**: Константы размазаны по коду, нужна система конфигурации.

**Варианты**:
- A: Dict-based config (простые словари)
- B: Dataclasses (@dataclass)
- C: Pydantic models (валидация)
- D: YAML/JSON файлы

**Выбор**: Вариант B (dataclasses) + опциональная загрузка из файлов

**Обоснование**:
- Dataclasses - стандартная библиотека Python 3.7+, нет зависимостей
- Type hints для IDE автокомплита
- Легко добавить валидацию через `__post_init__`
- Проще чем Pydantic, достаточно для проекта
- Можно добавить загрузку из JSON/YAML позже если нужно

**Последствия**:
- Создание папки `ursina/config/`
- 3 dataclass файла: TrainingConfig, VisualizationConfig, AppConfig
- Пресеты: 'low', 'medium', 'high'

---

## Decision 4: [2026-01-21] Разделение на Trainer + Visualizer

**Контекст**: train_calf_visual.py - 974 строки монолит, сложно читать и поддерживать.

**Варианты**:
- A: Оставить монолитом (проще, но неудобно)
- B: Разбить на 2 класса (Trainer + Visualizer)
- C: Разбить на 3+ классов (Trainer + Visualizer + StatsCollector + ...)
- D: Использовать существующий фреймворк (Stable-Baselines3, RLlib)

**Выбор**: Вариант B (Trainer + Visualizer)

**Обоснование**:
- 2 класса - баланс между простотой и модульностью
- Чёткое разделение обязанностей:
  - Trainer: логика обучения, buffer, train_step
  - Visualizer: визуальные агенты, heatmap, UI
- Легко тестировать по отдельности
- Вариант C (3+ классов) - overkill для текущего размера проекта
- Вариант D (фреймворк) - слишком тяжеловесно, теряем контроль

**Последствия**:
- Создание `ursina/training/trainer.py`
- Создание `ursina/training/visualizer.py`
- main.py координирует Trainer + Visualizer в update()

---

## Decision 5: [2026-01-21] Профилирование через context manager

**Контекст**: Нужна система отслеживания производительности операций.

**Варианты**:
- A: Ручные замеры (time.time() вокруг каждой операции)
- B: Декораторы (@profile)
- C: Context manager (with profiler.measure(...))
- D: Line profiler (kernprof)
- E: cProfile встроенный

**Выбор**: Вариант C (context manager)

**Обоснование**:
- Context manager - чистый синтаксис: `with profiler.measure('name'):`
- Низкий overhead (~0.1ms на замер)
- Легко добавить/убрать профилирование
- Агрегация статистики (min/max/avg/EMA)
- Варианты D/E (line profiler, cProfile) - для глубокого анализа, но тяжелы для real-time
- Декораторы (B) - не подходят для блоков кода внутри функций

**Последствия**:
- Создание `ursina/utils/profiler.py` с классом PerformanceProfiler
- UI отображение топ-5 операций
- Экспорт в CSV для детального анализа

---

## Decision 6: [YYYY-MM-DD] Название решения

**Контекст**:

**Варианты**:

**Выбор**:

**Обоснование**:

**Последствия**:

---
